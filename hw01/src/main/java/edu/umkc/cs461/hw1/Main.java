package edu.umkc.cs461.hw1;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import edu.umkc.cs461.hw1.data.*;
import edu.umkc.cs461.hw1.algorithms.*;

/*
 * Main demonstration class for the search algorithms
 */
public class Main {

    //Fixed file paths from the inputs. We could use the file paths from the inputs, but we are using the fixed file paths for the demonstration.
    private static final String CITIES_LIST    = "./data/coordinates.csv";
    private static final String ADJACENCY_LIST = "./data/Adjacencies.txt";

    private static final int MAX_ITERATIONS = 1000000;


    /*
     * Main method for the demonstration
     */
    public static void main(String[] args) {

        //Variables to store the user input
        boolean findAllRoutes = false;
        String startCity = null;
        String endCity   = null;
        String outfileName = null;

        //Code below generated by Co-Pilot
        System.out.println("Enter the start city: ");
        try(BufferedReader reader = new BufferedReader(new FileReader("/dev/stdin"))){
            startCity = reader.readLine();
        }catch(IOException readError){
            System.out.println("Error reading input.");
            System.exit(1);
        }

        System.out.println("Enter the end city: ");
        try(BufferedReader reader = new BufferedReader(new FileReader("/dev/stdin"))){
            endCity = reader.readLine();
        }catch(IOException readError){
            System.out.println("Error reading input.");
            System.exit(1);
        }

        System.out.println("Enter the output file name: ");
        try(BufferedReader reader = new BufferedReader(new FileReader("/dev/stdin"))){
            outfileName = reader.readLine();
        }catch(IOException readError){
            System.out.println("Error reading input.");
            System.exit(1);
        }

        System.out.println("Find all routes? (y/n): ");
        try(BufferedReader reader = new BufferedReader(new FileReader("/dev/stdin"))){
            findAllRoutes = reader.readLine().equals("y");
        }catch(IOException readError){
            System.out.println("Error reading input.");
            System.exit(1);
        }
        //End of Co-Pilot generated code

        System.out.println("Loading data...");

        //Load the list of cities; names and coordinates
        final List<City> cities = DataLoader.loadCities(CITIES_LIST);

        //Load the list of adjacencies as pairs of cities
        final List<NodePair<City>> adjacencies = DataLoader.loadAdjacencies(ADJACENCY_LIST, cities);

        //Create the graph
        BiDirectGraph.BiDirectGraphBuilder<City> builder = new BiDirectGraph.BiDirectGraphBuilder<City>();

        //Add the cities and adjacencies to the graph
        builder.addNodes(cities);
        builder.addEdges(adjacencies);

        //Build the graph based on the cities and adjacencies
        BiDirectGraph<City> graph = builder.build();

        System.out.println("Data loaded.");

        //Find the start city
        final int startIdx = graph.getIndex(new City(startCity));

        //If the start city is not found, print an error and exit
        if(startIdx == -1){
            System.out.println("Start city not found.");
            System.exit(1);
        }

        //Find the end city
        final int endIdx = graph.getIndex(new City(endCity));

        //If the end city is not found, print an error and exit
        if(endIdx == -1){
            System.out.println("End city not found.");
            System.exit(1);
        }

        //Create the output file
        File outputFile = null;
        
        try{
            outputFile = new File(outfileName);
        }catch(Exception e){
            System.out.println("Error creating output file.");
            System.out.println(e.getMessage());
            System.exit(1);
        }
        if(outputFile.exists()){
            outputFile.delete();
        }

        //Run the search algorithms
        try(FileWriter jsonOutput = new FileWriter(outputFile, true)){

            System.out.println("Finding route from " + cities.get(startIdx).getName() + " to " + cities.get(endIdx).getName());

            jsonOutput.write("{");
            jsonOutput.write("\"start\":\""+cities.get(startIdx).getName()+"\",");
            jsonOutput.write("\"end\":\""+cities.get(endIdx).getName()+"\",");
            jsonOutput.write("\"findAllPaths\":"+findAllRoutes+",");
            jsonOutput.write("\"searches\":[");

            /////////////////////////////////////////////////////////////////////////
            // Breadth First Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"BSF\",");
            System.out.println("BFS: ");
            runSearch(new BreadthFirst(cities.get(startIdx), cities.get(endIdx), graph), null, findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Flexi BFS
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"FlexBSF\",");
            System.out.println("Flexi BFS: ");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new QueueFrontier(), findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Depth First Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"DSF\",");
            System.out.println("DFS: ");
            runSearch(new DepthFirst(cities.get(startIdx), cities.get(endIdx), graph), null, findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Flexi DFS
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"FlexDSF\",");
            System.out.println("Flexi DFS: ");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new StackFrontier(), findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Iterative Deepening Depth First Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"IDDSF\",");
            System.out.println("IDDFS: ");
            runSearch(new IDDFS(cities.get(startIdx), cities.get(endIdx), graph), null, findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Flexi IDDFS
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"FlexiIDDSF\",");
            System.out.println("Flexi IDDFS: ");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new IDDFSFrontier(), findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Best First Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"BestFirst\",");
            System.out.println("Best First: ");
            runSearch(new BestFirst(cities.get(startIdx), cities.get(endIdx), graph), null, findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Flexi Best First Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"FlexiBestFirst\",");
            System.out.println("Flexi Best First:");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new BestFirstFrontier(cities.get(endIdx)), findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // A* Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"AStar\",");
            System.out.println("A*: ");
            runSearch(new AStar(cities.get(startIdx), cities.get(endIdx), graph), null, findAllRoutes, jsonOutput);
            jsonOutput.write("},");
    
            /////////////////////////////////////////////////////////////////////////
            // Flexi A* Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"FlexAStar\",");
            System.out.println("Flexi A*");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new AStarFrontier(cities.get(endIdx)), findAllRoutes, jsonOutput);
            jsonOutput.write("},");


            /////////////////////////////////////////////////////////////////////////
            // Random Flex Search
            /////////////////////////////////////////////////////////////////////////
            jsonOutput.write("{\"name\":\"RandomFlex\",");
            System.out.println("Random Flex: ");
            runSearch(new FlexiSearch(cities.get(startIdx), cities.get(endIdx), graph), new RandomFrontier(), findAllRoutes, jsonOutput);

            jsonOutput.write("}]}");
            jsonOutput.flush();
            
        }catch(IOException writeError){
            //
        }
    }

    //Run the search algorithm and write the results to the output file
    private static void runSearch(SearchState searchAlg, Frontier<SearchState.Node> frontier, boolean findAllRoutes, Writer fileOut)
    throws IOException
    {
        SearchState.FindResult findResult = null;

        //If we are finding all routes, run the search algorithm and write the results to the output file
        if(findAllRoutes){
            findResult = searchAlg.find(true, frontier);

        //If we are only finding the first route, run the search algorithm multiple times and write the results to the output file
        }else{
            final long bfStart = System.currentTimeMillis();
            for(int i = 0; i < MAX_ITERATIONS; i++){
                findResult = searchAlg.find(false, frontier);
            }
            final long bfEnd = System.currentTimeMillis();
            fileOut.write("\"iterations\":"+MAX_ITERATIONS+",");
            fileOut.write("\"time\":"+(bfEnd-bfStart)+",");
            System.out.println("Time: " + (bfEnd - bfStart) + "ms for " + MAX_ITERATIONS + " iterations");
        }


        List<City> path = findResult.routes.get(0);

        fileOut.write("\"firstRouteFound\":[");
        fileOut.write(String.join(",", path.stream().map(c -> "\""+c.getName()+"\"").collect(Collectors.toList())));
        fileOut.write("],");
        fileOut.write("\"distance\":"+City.distanceThrough(path));

        System.out.println("First Route: ");
        System.out.println("Distance: " + City.distanceThrough(path));
        System.out.println(String.join(" -> ", path.stream().map(c -> c.getName()).collect(Collectors.toList())));

        if(findAllRoutes){
            fileOut.write(",\"allRoutes\":[");

            System.out.println();
            System.out.println("All Routes: ");
            boolean isFirst = true;
            for(List<City> route : findResult.routes){
                if(!isFirst){
                    fileOut.write(",");
                }else{
                    isFirst = false;
                }
                fileOut.write("{\"route\":[");
                fileOut.write(String.join(",", route.stream().map(c -> "\""+c.getName()+"\"").collect(Collectors.toList())));
                fileOut.write("],");
                fileOut.write("\"distance\":"+City.distanceThrough(route));
                fileOut.write("}");

                System.out.println("Distance: " + City.distanceThrough(route));
                System.out.println("Route: ");
                System.out.println(String.join(" -> ", route.stream().map(c -> c.getName()).collect(Collectors.toList())));
                System.out.println();
            }
            fileOut.write("]");
        }else{
            fileOut.write(",\"visited\":[");
            fileOut.write(String.join(",", findResult.visitList.stream().map(c -> "\""+c.city.getName()+"\"").collect(Collectors.toList())));
            fileOut.write("]");

            System.out.println("Visited: ");
            System.out.println(String.join(" -> ", findResult.visitList.stream().map(c -> c.city.getName()).collect(Collectors.toList())));
        }        
        System.out.println();
        System.out.println();
    }

    private static class DataLoader {
        public static List<City> loadCities(final String filename) {
            List<City> cities = new ArrayList<City>();
            try {
                BufferedReader br = new BufferedReader(new FileReader(filename));
                String line;
                while ((line = br.readLine()) != null) {
                    String[] parts = line.split(",");
                    cities.add(new City(parts[0], Double.parseDouble(parts[1]), Double.parseDouble(parts[2])));
                }
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return cities;
        }

        public static List<NodePair<City>> loadAdjacencies(final String filename, final List<City> cities) {

            Map<String, City> cityMap = new java.util.HashMap<String, City>();
            for(City city : cities){
                cityMap.put(city.getName(), city);
            }

            List<NodePair<City>> adjacencies = new ArrayList<NodePair<City>>();
            try {
                BufferedReader br = new BufferedReader(new FileReader(filename));
                String line;
                while ((line = br.readLine()) != null) {
                    String[] parts = line.split(" ");                    
                    adjacencies.add(new NodePair<City>(cityMap.get(parts[0]), cityMap.get(parts[1])));
                }
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return adjacencies;
        }
    }
}
